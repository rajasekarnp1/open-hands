"""
Defines the state models for long-running agent sessions, including conversation history.
"""
from __future__ import annotations # For Python 3.7, 3.8 compatibility with Pydantic v2

from typing import List, Dict, Any, Optional, Union

from pydantic import BaseModel, Field

class Message(BaseModel):
    """
    Represents a single message in a conversation history.
    Compatible with OpenAI's message format and tool call structures.
    """
    role: str  # e.g., "system", "user", "assistant", "tool"

    # Content can be a simple string or a list of content blocks (e.g., for multimodal later)
    # For tool results, content is typically a string (output of the tool).
    # For assistant requesting tool calls, content might be null if tool_calls is present.
    content: Union[str, List[Dict[str, Any]], None] = None

    name: Optional[str] = None  # For "tool" role, the name of the tool that was called.
                                # For "assistant" role, can be assistant's name.

    # For assistant messages that want to call tools
    tool_calls: Optional[List[ToolCall]] = None

    # For "tool" messages that are results of a tool call
    tool_call_id: Optional[str] = None # ID from the assistant's tool_calls request

    class Config:
        # Pydantic v2: `model_config = {"validate_assignment": True}`
        # For Pydantic v1, this is default behavior.
        # We want to ensure that `content` can indeed be `None` if `tool_calls` is present.
        # The `Union[..., None]` and `Optional` already handle this.
        # `exclude_none=True` can be used during serialization if needed.
        pass

class ToolCallFunction(BaseModel):
    """Function details for a tool call, as expected by OpenAI models."""
    name: str
    arguments: str # JSON string of arguments

class ToolCall(BaseModel):
    """
    Represents a tool call requested by the assistant.
    Compatible with OpenAI's tool call format.
    """
    id: str # Unique ID for the tool call, generated by LLM
    function: ToolCallFunction
    type: str = "function" # Usually "function"


class SessionState(BaseModel):
    """
    Represents the state of an agent's session, primarily the conversation history.
    This state can be checkpointed to allow for long-running, stateful interactions.
    """
    conversation_history: List[Message] = Field(default_factory=list)

    # Optional unique identifier for the session or thread
    thread_id: Optional[str] = None

    # Additional state variables can be added here as needed:
    # current_plan: Optional[List[str]] = None
    # scratchpad: Dict[str, Any] = Field(default_factory=dict)
    # user_preferences: Dict[str, Any] = Field(default_factory=dict)
    # current_task_id: Optional[str] = None
    original_request_info: Optional[Dict[str, Any]] = None # Store key, non-sensitive parts of original CodeAgentRequest

    # Example: Storing last executed tool call info for context or debugging
    # last_tool_call: Optional[Dict[str, Any]] = None
    # last_tool_result: Optional[str] = None

    def add_message(self, role: str, content: Union[str, List[Dict[str, Any]], None],
                    name: Optional[str] = None,
                    tool_calls: Optional[List[Dict[str, Any]]] = None,
                    tool_call_id: Optional[str] = None) -> None:
        """Helper method to add a message to the conversation history."""
        self.conversation_history.append(Message(
            role=role,
            content=content,
            name=name,
            tool_calls=tool_calls,
            tool_call_id=tool_call_id
        ))

    def get_last_message(self, role: Optional[str] = None, ignore_system: bool = False) -> Optional[Message]:
        """
        Helper to get the last message, optionally filtered by role and ignoring system messages.
        """
        if not self.conversation_history:
            return None
        for msg in reversed(self.conversation_history):
            if ignore_system and msg.role == "system":
                continue
            if role is None or msg.role == role:
                return msg
        return None

    class Config:
        # Pydantic v2: `model_config = {"validate_assignment": True}`
        pass
```
