"""
Defines the state models for long-running agent sessions, including conversation history.
"""
from __future__ import annotations # For Python 3.7, 3.8 compatibility with Pydantic v2

from typing import List, Dict, Any, Optional, Union

from pydantic import BaseModel, Field
from .planning_models import Plan # Import Plan model

# --- Message and Tool Call Models ---

class ToolCallFunction(BaseModel):
    """Function details for a tool call, as expected by OpenAI models."""
    name: str
    arguments: str # JSON string of arguments

class ToolCall(BaseModel):
    """
    Represents a tool call requested by the assistant.
    Compatible with OpenAI's tool call format.
    """
    id: str # Unique ID for the tool call, generated by LLM
    function: ToolCallFunction
    type: str = "function" # Usually "function"

class Message(BaseModel):
    """
    Represents a single message in a conversation history.
    Compatible with OpenAI's message format and tool call structures.
    """
    role: str  # e.g., "system", "user", "assistant", "tool"
    content: Union[str, List[Dict[str, Any]], None] = None
    name: Optional[str] = None
    tool_calls: Optional[List[ToolCall]] = None
    tool_call_id: Optional[str] = None

    class Config:
        pass

# --- Session State Model ---

class SessionState(BaseModel):
    """
    Represents the state of an agent's session, including conversation history and current plan.
    This state can be checkpointed to allow for long-running, stateful interactions.
    """
    conversation_history: List[Message] = Field(default_factory=list)
    thread_id: Optional[str] = None

    # Stores key, non-sensitive parts of the original agent request
    # (e.g., CodeAgentRequest or PlanningAgentRequest)
    original_request_info: Optional[Dict[str, Any]] = None

    # Current plan being worked on by an agent
    current_plan: Optional[Plan] = None

    # Other potential state variables:
    # scratchpad: Dict[str, Any] = Field(default_factory=dict)
    # user_preferences: Dict[str, Any] = Field(default_factory=dict)
    # current_task_id: Optional[str] = None
    # current_step_id: Optional[str] = None

    def add_message(self, role: str, content: Union[str, List[Dict[str, Any]], None],
                    name: Optional[str] = None,
                    tool_calls: Optional[List[ToolCall]] = None, # Corrected type
                    tool_call_id: Optional[str] = None) -> None:
        """Helper method to add a message to the conversation history."""
        self.conversation_history.append(Message(
            role=role,
            content=content,
            name=name,
            tool_calls=tool_calls, # type: ignore - Pydantic handles this if input is dict
            tool_call_id=tool_call_id
        ))

    def get_last_message(self, role: Optional[str] = None, ignore_system: bool = False) -> Optional[Message]:
        """
        Helper to get the last message, optionally filtered by role and ignoring system messages.
        """
        if not self.conversation_history:
            return None
        for msg in reversed(self.conversation_history):
            if ignore_system and msg.role == "system":
                continue
            if role is None or msg.role == role:
                return msg
        return None

    class Config:
        pass
```
